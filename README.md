# **SPI Slave with Single Port RAM - Verified using UVM**

![SPI Protocol](Images/SPI_Protocol.gif)

SPI is a **synchronous serial communication protocol** used for **short-distance communication**, primarily in **embedded systems**. It enables a **master device** to communicate with **one or more slave devices** at high speeds using a **minimal number of I/O pins**.

This project implements an **SPI Slave with a Single-Port RAM**, fully **verified using UVM (Universal Verification Methodology)**.

---

## **üìå Project Highlights**
‚úÖ **SPI Slave Design**  
‚úÖ **Single-Port RAM for Data Storage**  
‚úÖ **Fully Verified with UVM**  
‚úÖ **Functional Coverage for Protocol Validation**  
‚úÖ **Randomized and Directed Test Scenarios**  
‚úÖ **Automated UVM Testbench**  

---

## **üîπ SPI Protocol**
The **Serial Peripheral Interface (SPI)** protocol consists of four main signals:

- **MOSI (Master Out Slave In)** ‚Üí Data from the master to the slave  
- **MISO (Master In Slave Out)** ‚Üí Data from the slave to the master  
- **SCLK (Serial Clock)** ‚Üí Clock signal generated by the master  
- **SS/CS (Slave Select/Chip Select)** ‚Üí Used by the master to select the slave device  

---

## **üîπ Project Components**
### **1Ô∏è‚É£ SPI Slave (`SPI.v`)**
Implements the SPI Slave interface.

#### **üîπ Ports**
| Name      | Type   | Size  | Description                  |
|-----------|--------|-------|------------------------------|
| `MOSI`    | Input  | 1 bit | Master Out Slave In         |
| `tx_valid`| Input  | 1 bit | Control for Input Data      |
| `tx_data` | Input  | 8 bits| Input Data for SPI Slave    |
| `rst_n`   | Input  | 1 bit | Active low reset            |
| `clk`     | Input  | 1 bit | Clock                        |
| `MISO`    | Output | 1 bit | Data Output                 |
| `rx_valid`| Output | 1 bit | Control for Output Data     |
| `rx_data` | Output | 10 bits| Output Data for SPI Slave  |

---

### **2Ô∏è‚É£ RAM (`ram.v`)**
Implements a **single-port RAM** for storing SPI transactions.

#### **üîπ Parameters**
- `MEM_DEPTH` ‚Üí Memory depth (default **256**)  
- `ADDR_SIZE` ‚Üí Address size (default **8 bits**)  

#### **üîπ Ports**
| Name      | Type   | Size  | Description                  |
|-----------|--------|-------|------------------------------|
| `din`     | Input  | 10 bits| Data Input                 |
| `clk`     | Input  | 1 bit  | Clock                      |
| `rst_n`   | Input  | 1 bit  | Active low reset           |
| `rx_valid`| Input  | 1 bit  | Accepts write/read address |
| `dout`    | Output | 8 bits | Data Output                |
| `tx_valid`| Output | 1 bit  | Data ready signal          |

---

### **3Ô∏è‚É£ SPI Wrapper (`SPI_Wrapper.v`)**
Connects the **SPI Slave** and **RAM** modules.
- **Manages** data transfer between SPI Slave and RAM.

---

## **üõ† SPI Communication States**

![SPI FSM](Images/SPI_FSM.png)

### **1Ô∏è‚É£ Write Address**
1. Master sends **write address** (`rx_data[9:8] = 2'b00`).
2. **`SS_n = 0`** to start communication.
3. SPI Slave detects **write command** and receives **10 bits**.
4. Converts **serial (MOSI) ‚Üí parallel (rx_data)**.
5. **`rx_valid = HIGH`** to signal RAM.
6. RAM saves **`din[7:0]` as write address**.
7. **`SS_n = 1`** to end communication.

   ![Write Address](Images/Write_ADD.png)

### **2Ô∏è‚É£ Write Data**
1. Master sends **write data** (`rx_data[9:8] = 2'b01`).
2. **`SS_n = 0`** to start communication.
3. SPI Slave detects **write data command** and receives **10 bits**.
4. Converts **serial (MOSI) ‚Üí parallel (rx_data)**.
5. **`rx_valid = HIGH`** to signal RAM.
6. RAM writes **data to stored address**.
7. **`SS_n = 1`** to end communication.

   ![Write Data](Images/Write_Data.png)

### **3Ô∏è‚É£ Read Address**
1. Master sends **read address** (`rx_data[9:8] = 2'b10`).
2. **`SS_n = 0`** to start communication.
3. SPI Slave detects **read command** and receives **10 bits**.
4. Converts **serial (MOSI) ‚Üí parallel (rx_data)**.
5. **`rx_valid = HIGH`** to signal RAM.
6. RAM stores **read address**.
7. **`SS_n = 1`** to end communication.

   ![Read Address](Images/Read_ADD.png)

### **4Ô∏è‚É£ Read Data**
1. Master sends **read data command** (`rx_data[9:8] = 2'b11`).
2. **`SS_n = 0`** to start communication.
3. SPI Slave detects **read data command** and receives **10 bits**.
4. Converts **serial (MOSI) ‚Üí parallel (rx_data)**.
5. RAM reads from **stored address**.
6. **`tx_valid = HIGH`** to signal SPI Slave.
7. SPI Slave sends **data on MISO** for **8 clock cycles**.
8. **`SS_n = 1`** to end communication.

   ![Read Data](Images/Read_Data.png)

---

## **üìå UVM-Based Verification**
## **üìå UVM-Based Verification**
The SPI Slave and RAM were **verified using UVM**, which includes:

- **UVM Testbench Architecture**
  - `SPI_env.sv` ‚Üí UVM Environment
  - `SPI_test.sv` ‚Üí UVM Testbench
  - `SPI_agent.sv` ‚Üí UVM Agent containing:
  - `SPI_sequencer.sv` ‚Üí Generates sequences
  - `SPI_driver.sv` ‚Üí Drives stimulus to DUT
  - `SPI_monitor.sv` ‚Üí Observes and collects transactions
  - `SPI_sequence.sv` ‚Üí Defines test sequences for different SPI operations
  - `SPI_seq_item.sv` ‚Üí Defines transaction-level items for SPI communication
  - `SPI_config.sv` ‚Üí Configuration settings for SPI testbench
  - `SPI_if.sv` ‚Üí UVM Interface to connect DUT with the UVM testbench
  - `SPI_scoreboard.sv` ‚Üí Compares actual DUT output with expected results
  - `SPI_coverage.sv` ‚Üí Defines and monitors functional coverage metrics

This structured testbench ensures **robust verification** of the SPI Slave with Single-Port RAM using **random and directed tests**.

---

## **üìå Getting Started**
### **1Ô∏è‚É£ Running the Simulation**
A **`SPI.do`** file automates compilation and simulation.

**Run the following command in the simulator console:**
```tcl
do SPI.do
